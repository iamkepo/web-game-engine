ğŸ§  Vue dâ€™ensemble (en une phrase)

Lâ€™application est un Ã©diteur desktop Electron qui pilote un moteur 3D web, sauvegarde tout en JSON, puis gÃ©nÃ¨re un runtime autonome exÃ©cutable partout.

â¸»

1ï¸âƒ£ Lancement de lâ€™application

Lâ€™utilisateur double-clique.

Ce qui se passe vraiment :
	â€¢	Electron dÃ©marre
	â€¢	main.ts crÃ©e une fenÃªtre
	â€¢	Le renderer charge lâ€™app React
	â€¢	Le preload expose une API sÃ©curisÃ©e (IPC)

ğŸ‘‰ Ã€ ce stade :
	â€¢	pas de 3D encore
	â€¢	pas de fichiers ouverts
	â€¢	juste lâ€™Ã©diteur

â¸»

2ï¸âƒ£ CrÃ©ation / ouverture dâ€™un projet

Lâ€™utilisateur crÃ©e un projet.

Electron (main process) :
	â€¢	crÃ©e un dossier local
	â€¢	initialise :
	â€¢	project.json
	â€¢	scene.json
	â€¢	assets/

ğŸ‘‰ Le projet est juste un dossier, rien de magique.

â¸»

3ï¸âƒ£ Le viewport 3D sâ€™initialise

Dans lâ€™Ã©diteur :
	â€¢	React affiche lâ€™UI
	â€¢	Un <canvas> est montÃ©
	â€¢	Three.js :
	â€¢	crÃ©e la scÃ¨ne
	â€¢	camÃ©ra
	â€¢	lumiÃ¨re
	â€¢	render loop

ğŸ‘‰ Important :
	â€¢	React ne gÃ¨re pas la 3D
	â€¢	React hÃ©berge juste le canvas

â¸»

4ï¸âƒ£ Import dâ€™un asset 3D

Lâ€™utilisateur clique â€œImporterâ€.

Flux rÃ©el :
	1.	React dÃ©clenche une action
	2.	IPC â†’ main.ts
	3.	Electron ouvre un file dialog
	4.	Le fichier est copiÃ© dans :

project/assets/models/


	5.	Three.js charge le modÃ¨le
	6.	Une preview est rendue offscreen
	7.	Metadata Ã©crite dans assets.index.json

ğŸ‘‰ Lâ€™Ã©diteur ne lit jamais directement le disque.

â¸»

5ï¸âƒ£ Ajout dans la scÃ¨ne

Lâ€™utilisateur glisse lâ€™asset dans la scÃ¨ne.

Ce qui se passe :
	â€¢	Une entitÃ© est crÃ©Ã©e
	â€¢	Elle reÃ§oit :
	â€¢	transform
	â€¢	mesh
	â€¢	Lâ€™entitÃ© est ajoutÃ©e Ã  scene.json

ğŸ‘‰ La scÃ¨ne est la source de vÃ©ritÃ©, pas Three.js.

â¸»

6ï¸âƒ£ Manipulation (move / rotate / scale)

Lâ€™utilisateur manipule lâ€™objet.

En coulisses :
	â€¢	Gizmo Three.js
	â€¢	Transform mis Ã  jour en mÃ©moire
	â€¢	Sync immÃ©diat dans scene.json

ğŸ‘‰ Si lâ€™app crash :
âœ”ï¸ le projet est toujours cohÃ©rent.

â¸»

7ï¸âƒ£ Sauvegarde automatique

Ã€ chaque changement :
	â€¢	scene.json est mis Ã  jour
	â€¢	pas de â€œSaveâ€ manuel
	â€¢	pas de perte de donnÃ©es

ğŸ‘‰ Oui, comme Figma.

â¸»

8ï¸âƒ£ Export du build ğŸš€

Lâ€™utilisateur clique â€œExporterâ€.

Electron fait :
	â€¢	crÃ©e /build
	â€¢	copie :
	â€¢	runtime.js
	â€¢	index.html
	â€¢	scene.json
	â€¢	assets utilisÃ©s
	â€¢	remplace les chemins

ğŸ‘‰ Le build est 100 % indÃ©pendant.

â¸»

9ï¸âƒ£ ExÃ©cution du build

Lâ€™utilisateur ouvre index.html.

Le runtime :
	1.	Charge scene.json
	2.	Initialise Three.js
	3.	Charge les assets
	4.	CrÃ©e les entitÃ©s
	5.	Lance la render loop

ğŸ‘‰ Aucun React.
ğŸ‘‰ Aucun Electron.
ğŸ‘‰ Juste du web pur.

â¸»

ğŸ” Cycle de vie complet

Ã‰diteur (Electron + React)
   â†“
JSON (scene / assets)
   â†“
Export
   â†“
Runtime Web (Three.js)


â¸»

ğŸ§  Pourquoi cette architecture est intelligente
	â€¢	SÃ©paration nette des responsabilitÃ©s
	â€¢	ZÃ©ro lock-in
	â€¢	Facile Ã  dÃ©boguer
	â€¢	Facile Ã  Ã©tendre (physique, blueprint, plugins)
	â€¢	Tu peux tout montrer, tout expliquer

â¸»

ğŸ¯ Ce que tu pourras ajouter ensuite
	â€¢	Blueprint â†’ lit le mÃªme JSON
	â€¢	Rapier â†’ plug dans runtime
	â€¢	Plugins â†’ injectent composants
	â€¢	Multiplayer â†’ synchronise JSON
	â€¢	Cloud â†’ sync projet